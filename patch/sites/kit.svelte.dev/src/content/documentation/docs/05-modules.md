---
title: Модули
---

В SvelteKit есть несколько модулей, которые доступны вашему приложению.

### $app/env

```js
import { amp, browser, dev, prerendering } from '$app/env';
```

- `amp` равен либо `true`, либо `false` в зависимости от соответствующего значения в [конфигурации проекта](#konfiguracziya)
- `browser` будет равен `true` или `false` если приложение запущено соответственно в браузере или на сервере
- `dev` равен `true` в режиме разработки, `false` в рабочем режиме
- `prerendering` равен `true` во время [перерендера](#ssr-i-javascript-prerender), иначе `false`

### $app/navigation

```js
import { goto, invalidate, prefetch, prefetchRoutes } from '$app/navigation';
```

- `goto(href, { replaceState, noscroll, state })` возвращает объект `Promise`, который выполняется, когда SvelteKit перемещается (или не может переместиться, тогда промис завершается с ошибкой) по указанному в `href` пути. Второй аргумент опционален. Если в `replaceState` будет задано `true`, адрес просто заменится, не будет создано дополнительной записи в истории браузера. При `noscroll` равным `true`, браузер не будет перематывать страницу на начало при переходе. Если `state` установлен, его значение будет использоваться для установки начального состояния новой записи в истории, по умолчанию это `{}`.
- `invalidate(href)` перезапускает все функции `load`, которые нужны для текущей активной страницы для повторной загрузки необходимых ресурсов. Возвращает объект `Promise`, который разрешается, когда страница обновится новыми данными.
- `prefetch(href)` программно  выполняет упреждающую загрузку указанной страницы, что означает: а) обеспечение полной загрузки кода для страницы и б) вызов метода `load` страницы с соответствующими параметрами. Это поведение, аналогично случаю, когда пользователь касается на сенсорном экране или проводит курсором над элементом `<a>` с установленным атрибутом [sveltekit:prefetch](docs#atributy-ssylok-sveltekit-prefetch). Если следующий переход будет по пути `href`, то будет использовано значение, которое вернула функция `load`, что сделает перемещение мгновенным. Возвращает объект `Promise`, который разрешается, когда упреждающая загрузка будет завершена.
- `prefetchRoutes(routes)` — программно выполняет упреждающую загрузку кода для маршрутов, которые ещё не были загружены до этого. Обычно используется для ускорения переходов по нижестоящим маршрутам. Если не передавать аргументов, то будут предзагружены все маршруты, но можете указать маршруты по любому подходящему пути, например, `/about` (для `src/routes/about.svelte`) или `/blog/*` (для `src/routes/blog/[slug].svelte`). В отличие от `prefetch`, это не вызовет функцию `load` для каждой из загружаемых страниц.  Возвращает объект `Promise`, который разрешается, когда упреждающая загрузка всех маршрутов будет завершена.

### $app/paths

```js
import { base, assets } from '$app/paths';
```

- `base` — строка с путём, относительно корня (т.е. начинается с `/`), которая соответствует параметру `config.kit.paths.base` в [конфигурации проекта](#konfiguracziya)
- `assets` — путь от корня или абсолютный путь который соответствует параметру `config.kit.paths.assets` (после его разрешения относительно `base`)

### $app/stores

```js
import { getStores, navigating, page, session } from '$app/stores';
```
Эти хранилища _зависят от контекста_, так как они добавляются в [контекст](https://ru.svelte.dev/tutorial/context-api) корневого компонента приложения. Это значит, что хранилища `session` и `page` будут уникальны для каждого запроса на сервер и не будут предоставлять одну и ту же информацию в нескольких запросах сразу. Поэтому можно безопасно хранить в `session` данные конкретного пользователя.

По этой причине доступ к хранилищу можно получить только во время инициализации компонента, как и в случае с любой функцией, которая использует метод `getContext` внутри.

- `getStores` – это удобная функция-оболочка вокруг `getContext`, которая возвращает `{ navigating, page, session }`. В большинстве случаев её использование не требуется.

Хранилища сами определяют нужный контекст, когда выполняется подписка на них. То есть вы можете импортировать и сразу использовать хранилище в компоненте без необходимости писать лишний код.

- `navigating` – [хранилище](https://ru.svelte.dev/tutorial/readable-stores). При начале совершения перехода его значение становится равным `{ from, to }`, где `from` и `to` значения соответствующих хранилищ страниц `page`. Когда навигация завершается, его значение становится равным `null`.
- `page` – хранилище, чьё значение равно объекту, который передаётся функции `load`, содержащему поля `host`, `path`, `params` и `query`. Подробнее в [раздел `page`](#zagruzka-dannyh-poluchaemye-znacheniya-page) выше.
- `session` – хранилище, начальное значение которого получается из функции [`getSession`](#huki-getsession). Значение в хранилище можно изменять, но эти изменения не будут сохранены на сервере – при необходимости это нужно имплементировать самостоятельно.

### $lib

Это простой псевдоним для директории `src/lib`, или иной директории указанной в [`config.kit.files.lib`](#konfiguracziya). Он позволит обращаться к общим компонентам и утилитам без использования множества `../../../../` в путях импорта.

### $service-worker

Этот модуль доступен только в [сервис-воркерах](#servis-vorkery).

```js
import { build, files, timestamp } from '$service-worker';
```

- `build` – массив строк URL путей до файлов сгенерированных Vite, используется для кеширования при помощи функции `cache.addAll(build)`
- `files` – массив строк URL путей до файлов в директории `static`, или иной директории указанной в [`config.kit.files.assets`](#konfiguracziya)
- `timestamp` – результат вызова функции `Date.now()` во время сборки. Полезно для генерации уникальных имён для кешей внутри сервис-воркера, что позволит инвалидировать устаревшие кеши у клиентов при запуске новой версии приложения.