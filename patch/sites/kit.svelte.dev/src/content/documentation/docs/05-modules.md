---
title: Модули
---

В SvelteKit есть несколько модулей, которые доступны вашему приложению.


### $app/env

```js
import { amp, browser, dev, mode, prerendering } from '$app/env';
```

- `amp` равен либо `true`, либо `false` в зависимости от соответствующего значения в [конфигурации проекта](#konfiguracziya)
- `browser` будет равен `true` или `false` если приложение запущено соответственно в браузере или на сервере
- `dev` равен `true` в режиме разработки, `false` в рабочем режиме
- `mode` - это [Vite mode](https://vitejs.dev/guide/env-and-mode.html#modes), по-умолчанию `development` в режиме разработки или `production` во время сборки, если иное не настроено в `config.kit.vite.mode`.
- `prerendering` равен `true` во время [перерендера](#parametry-straniczy-prerender), иначе `false`


### $app/navigation

```js
import {
 	disableScrollHandling,
 	goto,
 	invalidate,
 	prefetch,
 	prefetchRoutes,
 	beforeNavigate,
 	afterNavigate
 } from '$app/navigation';
```

- `afterNavigate(({ from, to }: { from: URL, to: URL }) => void)` - функция жизненного цикла, которая запускается при монтаже компонентов и после последующей навигации, пока компонент остается смонтированным
- `beforeNavigate(({ from, to, cancel }: { from: URL, to: URL | null, cancel: () => void }) => void)` — функция, которая запускается всякий раз, когда запускается навигация, будь то при нажатии на ссылку, вызове `goto` или с помощью кнопок истории браузера. Это включает в себя навигацию по внешним сайтам. `to` будет `null`, если пользователь закрывает страницу. Вызов `cancel` предотвратит продолжение навигации
- `disableScrollHandling`, если он вызывается при обновлении страницы после навигации (например, в `onMount` или действии), то запретит SvelteKit применять обычное управление прокруткой. Лучше избегать этого, чтобы не дезориентировать пользователей в поведении прокрутки.
- `goto(href, { replaceState, noscroll, keepfocus, state })` возвращает `Promise`, который резолвится при навигации SvelteKit к указанному `href` (ошибка в навигации отклоняет промис). Второй аргумент является необязательным:
    - `replaceState` (boolean, по умолчанию `false`) Если `true`, заменит текущую запись `history`, а не создадет новую на `pushState`
    - `noscroll` (boolean, по умолчанию `false`) Если `true`, браузер сохранит свое положение прокрутки, а не прокрутит в верхнюю часть страницы после навигации
    - `keepfocus` (boolean, по умолчанию `false`) Если `true`, текущий сфокусированный элемент сохранит фокус после навигации. В противном случае фокус будет сброшен на body
    - `state` (объект, по умолчанию `{}`) Состояние новой/обновленной записи истории
- `invalidate(href)` перезапускает все функции `load`, которые нужны для текущей активной страницы для повторной загрузки необходимых ресурсов. Возвращает объект `Promise`, который разрешается, когда страница обновится новыми данными.
- `prefetch(href)` программно  выполняет упреждающую загрузку указанной страницы, что означает: а) обеспечение полной загрузки кода для страницы и б) вызов метода `load` страницы с соответствующими параметрами. Это поведение, аналогично случаю, когда пользователь касается на сенсорном экране или проводит курсором над элементом `<a>` с установленным атрибутом [sveltekit:prefetch](docs#atributy-ssylok-sveltekit-prefetch). Если следующий переход будет по пути `href`, то будет использовано значение, которое вернула функция `load`, что сделает перемещение мгновенным. Возвращает объект `Promise`, который разрешается, когда упреждающая загрузка будет завершена.
- `prefetchRoutes(routes)` — программно выполняет упреждающую загрузку кода для маршрутов, которые ещё не были загружены до этого. Обычно используется для ускорения переходов по нижестоящим маршрутам. Если не передавать аргументов, то будут предзагружены все маршруты, но можете указать маршруты по любому подходящему пути, например, `/about` (для `src/routes/about.svelte`) или `/blog/*` (для `src/routes/blog/[slug].svelte`). В отличие от `prefetch`, это не вызовет функцию `load` для каждой из загружаемых страниц.  Возвращает объект `Promise`, который разрешается, когда упреждающая загрузка всех маршрутов будет завершена.


### $app/paths

```js
import { base, assets } from '$app/paths';
```

- `base` — строка с путём, относительно корня (т.е. начинается с `/`), которая соответствует параметру `config.kit.paths.base` в [конфигурации проекта](#konfiguracziya)
- `assets` — путь от корня или абсолютный путь который соответствует параметру `config.kit.paths.assets` (после его разрешения относительно `base`)

> Если указано значение `config.kit.paths.assets`, оно будет заменено на `'/_svelte_kit_assets'` во время [`svelte-kit dev`](#svelte-kit-cli-svelte-kit-dev) или [`svelte-kit preview`](#svelte-kit-cli-svelte-kit-preview), так как активы еще не находятся по их конечному URL-адресу.


### $app/stores

```js
import { getStores, navigating, page, session } from '$app/stores';
```
Эти хранилища _зависят от контекста_, так как они добавляются в [контекст](https://ru.svelte.dev/tutorial/context-api) корневого компонента приложения. Это значит, что хранилища `session` и `page` будут уникальны для каждого запроса на сервер и не будут предоставлять одну и ту же информацию в нескольких запросах сразу. Поэтому можно безопасно хранить в `session` данные конкретного пользователя.

По этой причине доступ к хранилищу можно получить только во время инициализации компонента, как и в случае с любой функцией, которая использует метод `getContext` внутри.

- `getStores` – это удобная функция-оболочка вокруг `getContext`, которая возвращает `{ navigating, page, session }`. Это необходимо вызывать на верхнем уровне или синхронно во время инициализации компонента или страницы.

Хранилища сами определяют нужный контекст, когда выполняется подписка на них, что означает, что вы можете импортировать и использовать их непосредственно в компонентах без шаблона. Тем не менее, его все еще нужно вызывать синхронно при инициализации компонента или страницы, когда `$`—префикс не используется. Вместо этого используйте `getStores`, чтобы безопасно `.subscribe` асинхронно.

- `navigating` - это [хранилище](https://svelte.dev/tutorial/readable-stores). При запуске навигации его значением является `{ from, to }`, где `from` и `to` являются экземплярами [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL). Когда навигация заканчивается, ее значение возвращается к `null`.
- `page` содержит объект с текущими [`url`](https://developer.mozilla.org/en-US/docs/Web/API/URL), [`params`](#zagruzka-dannyh-poluchaemye-znacheniya-params), [`stuff`](#zagruzka-dannyh-vozvrashhaemye-znacheniya-stuff), [`status`](#loading-output-status) и [`error`](#loading-output-error).
- `session` – хранилище, начальное значение которого получается из функции [`getSession`](#huki-getsession). Значение в хранилище можно изменять, но эти изменения не будут сохранены на сервере – при необходимости это нужно имплементировать самостоятельно.


### $lib

Это простой псевдоним для директории `src/lib`, или иной директории указанной в [`config.kit.files.lib`](#konfiguracziya). Он позволит обращаться к общим компонентам и утилитам без использования множества `../../../../` в путях импорта.


### $service-worker

Этот модуль доступен только в [сервис-воркерах](#servis-vorkery).

```js
import { build, files, timestamp } from '$service-worker';
```

- `build` – массив строк URL путей до файлов сгенерированных Vite, используется для кеширования при помощи функции `cache.addAll(build)`
- `files` - это массив строк URL, представляющих файлы в вашем каталоге `static` или любой другой каталог, указанный [`config.kit.files.assets`](#konfiguracziya). Вы можете настроить, какие файлы включаются из каталога `static`, используя [`config.kit.serviceWorker.files`](#konfiguracziya)
- `timestamp` – результат вызова функции `Date.now()` во время сборки. Полезно для генерации уникальных имён для кешей внутри сервис-воркера, что позволит инвалидировать устаревшие кеши у клиентов при запуске новой версии приложения.


### @sveltejs/kit/hooks

Этот модуль предоставляют хелпер-функцию для создания последовательности из нескольких вызовов в `handle`.

```js
import { sequence } from '@sveltejs/kit/hooks';

async function first({ event, resolve }) {
   console.log('first pre-processing');
 	const result = await resolve(event);
 	console.log('first post-processing');
 	return result;
}
async function second({ event, resolve }) {
   console.log('second pre-processing');
 	const result = await resolve(event);
 	console.log('second post-processing');
 	return result;
}

export const handle = sequence(first, second);
```

Пример выше распечатает:
>first pre-processing
>second pre-processing
>second post-processing
>first post-processing