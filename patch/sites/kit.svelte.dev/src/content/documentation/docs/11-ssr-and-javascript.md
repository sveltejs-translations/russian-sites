---
title: SSR и JavaScript
---

По умолчанию SvelteKit сначала отрисовывает любой компонент на сервере и отправляет его клиенту в формате HTML. Затем он снова отрисует компонент в браузере, чтобы сделать его интерактивным в процессе, называемом **гидратация**. По этой причине необходимо убедиться, что компоненты могут работать в обоих местах. Затем SvelteKit инициализирует [**роутер**](#marshruty), который берет на себя последующую навигацию.

Каждый из этих шагов можно контролировать как во всём приложении сразу, так и отдельно для каждой страницы. Обратите внимание, что все настройки, которые указываются для конкретных страниц, помещаются в блок `script` с атрибутом [`context="module"`](https://ru.svelte.dev/docs#script_context_module) и применяется только к компонентам страниц, _но не_ к [макетам](#makety).

Когда указаны настройки для приложения целиком и отдельно для каждой страницы, последние будут иметь приоритет, для предотвращения конфликтов. Любая из настроек может быть указана независимо друг от друга, но `ssr` и `hydrate` вместе не могут быть равны `false`, поскольку в этом случае на странице вообще ничего не будет отрисовано.

### ssr

Отключение [отрисовки на стороне сервера(SSR)](#prilozhenie-ssr) превращает ваше приложение SvelteKit в [одностраничное SPA приложение](#prilozhenie-csr-and-spa).

> В большинстве случаев отключение SSR не рекомендуется:  См. [обсуждение в приложении](#prilozhenie-ssr). Подумайте, действительно ли уместно отключить SSR, а не просто отключить SSR, потому что вы столкнулись с проблеммой.

Целиком отключить SSR во всём приложении можно [параметром `ssr`](#konfiguracziya-ssr) в конфигурации или для конкретной страницы экспортировав константу `ssr`: 

```html
<script context="module">
	export const ssr = false;
</script>
```

### router

В SvelteKit есть [клиентский роутер](#prilozhenie-routing), который отслеживает переходы (когда пользователь кликает на ссылки или на кнопки браузера Вперед/Назад) и обновляет содержимое страницы, не допуская перезагрузки страницы, как при обычной навигации в браузере.

В каких-то случаях может потребоваться отключить [клиентский роутер](#prilozhenie-routing) [параметром `router`](#konfiguracziya-router) в конфигурации приложения или для отдельной страницы экспортировав `router`:

```html
<script context="module">
	export const router = false;
</script>
```

Это отключит роутер для всех переходов с текущей страницы, даже если роутер уже был запущен в приложении.

### hydrate

Обычно SvelteKit [гидрирует](#prilozhenie-hydration) полученный с сервера HTML в интерактивную страницу. Некоторым страницам совершенно не нужен JavaScript – например, различного рода посты в блоге или страницы типа 'О сайте'. В таких случаях можно отключить гидрацию при загрузке приложения глобальным [`параметром hydrate`](#konfiguracziya-hydrate) в конфигурации или для конкретной страницы, экспортировав константу `hydrate`:

```html
<script context="module">
	export const hydrate = false;
</script>
```

> Если и `hydrate` и `router` будут оба равны `false`, SvelteKit вообще не добавит на страницу никакого JavaScript кода.

### prerender

Вполне вероятно, что по крайней мере некоторые страницы вашего приложения могут быть представлены в виде простого HTML-файла, созданного во время сборки. Эти страницы могут быть [_prerendered_](#prilozhenie-prerendering) вашим [адаптером](#adaptery).

Если приложение целиком подходит для пререндера, можно использовать адаптер статики ([`adapter-static`](https://github.com/sveltejs/kit/tree/master/packages/adapter-static)), который сгенерирует HTML-файлы для каждой страницы, а также дополнительные файлы, которые запрашиваются функцией `load` на этих страницах.

Чтобы выполнить пререндер для определённых страниц приложения, нужно пометить такие страницы специальным образом:

```html
<script context="module">
	export const prerender = true;
</script>
```

Пререндер запустится в корне приложения и сгенерирует HTML для всех найденных им страниц подходящих для предварительной отрисовки. Каждая страница сканируется на предмет элементов `<a>`, которые указывают на другие страницы, которые тоже могут быть отрисованы - поэтому нет необходимости явно указывать какие именно страницы нужно обработать. При необходимости, список страниц, которые должны быть предварительно отрисованы можно задать в параметре `pages` в разделе конфигурации [`prerender`](#konfiguracziya-prerender).

### Когда не делать пререндер

Основное правило таково: для того, чтобы страница могла быть предварительно отрисована, любые два пользователя, попадающие на одну и ту же страницу вашего приложения, должны получать с сервера одно и то же содержимое.

> Не все страницы подходят для предварительного рендеринга. Любой контент, который будет предварительно отрендерен, будет виден всем пользователям. Конечно, вы можете получить персонализированные данные в `onMount` на предварительно отрендеренной странице, но это может привести к более плохому пользовательскому опыту, так как это будет включать пустое начальное содержимое или индикаторы загрузки.

Обратите внимание, что вы всё ещё можете выполнить пререндер для приложения с динамическими маршрутами, как в нашем примере `src/routes/blog/[slug].svelte`. Адаптер статики будет обрабатывать запросы к серверу внутри функций `load`, поэтому данные, поступающие из `src/routes/blog/[slug].json.js` тоже будут сохранены. Конечно, вы можете получить персонализированные данные в `onMount` на предварительно отрендеренной странице, но это может привести к более плохому пользовательскому опыту, так как это будет включать пустое начальное содержимое или индикаторы загрузки.

### Конфликты маршрутов

Поскольку пререндер создаёт отражение всех маршрутов в виде файлового дерева, то невозможно иметь два эндпоинта, где возникает ситуация, что директория и файл в одном и том же месте будут иметь одинаковое имя. Например, `src/routes/foo/index.js` и `src/routes/foo/bar.js` будут пытаться создать файлы `foo` и `foo/bar`, что приведёт к ошибке.

По этой причине, рекомендуется всегда добавлять расширение к имени файла — например, `src/routes/foo/index.json.js` и `src/routes/foo/bar.json.js` будут сохранены как `foo.json` и `foo/bar.json`, которые не будут мешать друг другу.

Для маршрутов страниц этой проблемы не возникает, поскольку создаётся файл `foo/index.html`, а не `foo`.